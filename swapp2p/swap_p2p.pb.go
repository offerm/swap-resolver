// Code generated by protoc-gen-go. DO NOT EDIT.
// source: swap_p2p.proto

/*
Package hashresolver is a generated protocol buffer package.

It is generated from these files:
	swap_p2p.proto

It has these top-level messages:
	TakeOrderReq
	TakeOrderResp
	SuggestDealReq
	SuggestDealResp
	SwapReq
	SwapResp
*/
package swapresolver

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CoinType int32

const (
	CoinType_BTC CoinType = 0
	CoinType_LTC CoinType = 1
)

var CoinType_name = map[int32]string{
	0: "BTC",
	1: "LTC",
}
var CoinType_value = map[string]int32{
	"BTC": 0,
	"LTC": 1,
}

func (x CoinType) String() string {
	return proto.EnumName(CoinType_name, int32(x))
}
func (CoinType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type TakeOrderReq struct {
	Orderid     string   `protobuf:"bytes,1,opt,name=orderid" json:"orderid,omitempty"`
	TakerAmount int64    `protobuf:"varint,2,opt,name=taker_amount,json=takerAmount" json:"taker_amount,omitempty"`
	TakerCoin   CoinType `protobuf:"varint,3,opt,name=taker_coin,json=takerCoin,enum=hashresolver.CoinType" json:"taker_coin,omitempty"`
	MakerAmount int64    `protobuf:"varint,4,opt,name=maker_amount,json=makerAmount" json:"maker_amount,omitempty"`
	MakerCoin   CoinType `protobuf:"varint,5,opt,name=maker_coin,json=makerCoin,enum=hashresolver.CoinType" json:"maker_coin,omitempty"`
}

func (m *TakeOrderReq) Reset()                    { *m = TakeOrderReq{} }
func (m *TakeOrderReq) String() string            { return proto.CompactTextString(m) }
func (*TakeOrderReq) ProtoMessage()               {}
func (*TakeOrderReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *TakeOrderReq) GetOrderid() string {
	if m != nil {
		return m.Orderid
	}
	return ""
}

func (m *TakeOrderReq) GetTakerAmount() int64 {
	if m != nil {
		return m.TakerAmount
	}
	return 0
}

func (m *TakeOrderReq) GetTakerCoin() CoinType {
	if m != nil {
		return m.TakerCoin
	}
	return CoinType_BTC
}

func (m *TakeOrderReq) GetMakerAmount() int64 {
	if m != nil {
		return m.MakerAmount
	}
	return 0
}

func (m *TakeOrderReq) GetMakerCoin() CoinType {
	if m != nil {
		return m.MakerCoin
	}
	return CoinType_BTC
}

type TakeOrderResp struct {
	RPreimage []byte `protobuf:"bytes,1,opt,name=r_preimage,json=rPreimage,proto3" json:"r_preimage,omitempty"`
}

func (m *TakeOrderResp) Reset()                    { *m = TakeOrderResp{} }
func (m *TakeOrderResp) String() string            { return proto.CompactTextString(m) }
func (*TakeOrderResp) ProtoMessage()               {}
func (*TakeOrderResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *TakeOrderResp) GetRPreimage() []byte {
	if m != nil {
		return m.RPreimage
	}
	return nil
}

type SuggestDealReq struct {
	Orderid     string   `protobuf:"bytes,1,opt,name=orderid" json:"orderid,omitempty"`
	TakerDealId string   `protobuf:"bytes,2,opt,name=taker_deal_id,json=takerDealId" json:"taker_deal_id,omitempty"`
	TakerAmount int64    `protobuf:"varint,3,opt,name=taker_amount,json=takerAmount" json:"taker_amount,omitempty"`
	TakerCoin   CoinType `protobuf:"varint,4,opt,name=taker_coin,json=takerCoin,enum=hashresolver.CoinType" json:"taker_coin,omitempty"`
	MakerAmount int64    `protobuf:"varint,5,opt,name=maker_amount,json=makerAmount" json:"maker_amount,omitempty"`
	MakerCoin   CoinType `protobuf:"varint,6,opt,name=maker_coin,json=makerCoin,enum=hashresolver.CoinType" json:"maker_coin,omitempty"`
	TakerPubkey string   `protobuf:"bytes,7,opt,name=taker_pubkey,json=takerPubkey" json:"taker_pubkey,omitempty"`
}

func (m *SuggestDealReq) Reset()                    { *m = SuggestDealReq{} }
func (m *SuggestDealReq) String() string            { return proto.CompactTextString(m) }
func (*SuggestDealReq) ProtoMessage()               {}
func (*SuggestDealReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SuggestDealReq) GetOrderid() string {
	if m != nil {
		return m.Orderid
	}
	return ""
}

func (m *SuggestDealReq) GetTakerDealId() string {
	if m != nil {
		return m.TakerDealId
	}
	return ""
}

func (m *SuggestDealReq) GetTakerAmount() int64 {
	if m != nil {
		return m.TakerAmount
	}
	return 0
}

func (m *SuggestDealReq) GetTakerCoin() CoinType {
	if m != nil {
		return m.TakerCoin
	}
	return CoinType_BTC
}

func (m *SuggestDealReq) GetMakerAmount() int64 {
	if m != nil {
		return m.MakerAmount
	}
	return 0
}

func (m *SuggestDealReq) GetMakerCoin() CoinType {
	if m != nil {
		return m.MakerCoin
	}
	return CoinType_BTC
}

func (m *SuggestDealReq) GetTakerPubkey() string {
	if m != nil {
		return m.TakerPubkey
	}
	return ""
}

type SuggestDealResp struct {
	Orderid     string `protobuf:"bytes,1,opt,name=orderid" json:"orderid,omitempty"`
	RHash       []byte `protobuf:"bytes,2,opt,name=r_hash,json=rHash,proto3" json:"r_hash,omitempty"`
	MakerDealId string `protobuf:"bytes,3,opt,name=maker_deal_id,json=makerDealId" json:"maker_deal_id,omitempty"`
	MakerPubkey string `protobuf:"bytes,4,opt,name=maker_pubkey,json=makerPubkey" json:"maker_pubkey,omitempty"`
}

func (m *SuggestDealResp) Reset()                    { *m = SuggestDealResp{} }
func (m *SuggestDealResp) String() string            { return proto.CompactTextString(m) }
func (*SuggestDealResp) ProtoMessage()               {}
func (*SuggestDealResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SuggestDealResp) GetOrderid() string {
	if m != nil {
		return m.Orderid
	}
	return ""
}

func (m *SuggestDealResp) GetRHash() []byte {
	if m != nil {
		return m.RHash
	}
	return nil
}

func (m *SuggestDealResp) GetMakerDealId() string {
	if m != nil {
		return m.MakerDealId
	}
	return ""
}

func (m *SuggestDealResp) GetMakerPubkey() string {
	if m != nil {
		return m.MakerPubkey
	}
	return ""
}

type SwapReq struct {
	MakerDealId string `protobuf:"bytes,1,opt,name=maker_deal_id,json=makerDealId" json:"maker_deal_id,omitempty"`
}

func (m *SwapReq) Reset()                    { *m = SwapReq{} }
func (m *SwapReq) String() string            { return proto.CompactTextString(m) }
func (*SwapReq) ProtoMessage()               {}
func (*SwapReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SwapReq) GetMakerDealId() string {
	if m != nil {
		return m.MakerDealId
	}
	return ""
}

type SwapResp struct {
	RPreimage []byte `protobuf:"bytes,1,opt,name=r_preimage,json=rPreimage,proto3" json:"r_preimage,omitempty"`
}

func (m *SwapResp) Reset()                    { *m = SwapResp{} }
func (m *SwapResp) String() string            { return proto.CompactTextString(m) }
func (*SwapResp) ProtoMessage()               {}
func (*SwapResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SwapResp) GetRPreimage() []byte {
	if m != nil {
		return m.RPreimage
	}
	return nil
}

func init() {
	proto.RegisterType((*TakeOrderReq)(nil), "hashresolver.TakeOrderReq")
	proto.RegisterType((*TakeOrderResp)(nil), "hashresolver.TakeOrderResp")
	proto.RegisterType((*SuggestDealReq)(nil), "hashresolver.SuggestDealReq")
	proto.RegisterType((*SuggestDealResp)(nil), "hashresolver.SuggestDealResp")
	proto.RegisterType((*SwapReq)(nil), "hashresolver.SwapReq")
	proto.RegisterType((*SwapResp)(nil), "hashresolver.SwapResp")
	proto.RegisterEnum("hashresolver.CoinType", CoinType_name, CoinType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for P2P service

type P2PClient interface {
	// TakeOrder is called to initiate a swap between maker and taker
	// it is a temporary service needed until the integration with XUD
	// intended to be called from CLI to simulate order taking by taker
	TakeOrder(ctx context.Context, in *TakeOrderReq, opts ...grpc.CallOption) (*TakeOrderResp, error)
	// SuggestDeal is called by the taker to inform the maker that he
	// would like to execute a swap. The maker may reject the request
	// for now, the maker can only accept/reject and can't rediscuss the
	// deal or suggest partial amount. If accepted the maker should respond
	// with a hash that would be used for teh swap.
	SuggestDeal(ctx context.Context, in *SuggestDealReq, opts ...grpc.CallOption) (*SuggestDealResp, error)
	// Swap initiates the swap. It is called by the taker to confirm that
	// he has the hash and confirm the deal.
	Swap(ctx context.Context, in *SwapReq, opts ...grpc.CallOption) (*SwapResp, error)
}

type p2PClient struct {
	cc *grpc.ClientConn
}

func NewP2PClient(cc *grpc.ClientConn) P2PClient {
	return &p2PClient{cc}
}

func (c *p2PClient) TakeOrder(ctx context.Context, in *TakeOrderReq, opts ...grpc.CallOption) (*TakeOrderResp, error) {
	out := new(TakeOrderResp)
	err := grpc.Invoke(ctx, "/hashresolver.P2P/TakeOrder", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) SuggestDeal(ctx context.Context, in *SuggestDealReq, opts ...grpc.CallOption) (*SuggestDealResp, error) {
	out := new(SuggestDealResp)
	err := grpc.Invoke(ctx, "/hashresolver.P2P/SuggestDeal", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *p2PClient) Swap(ctx context.Context, in *SwapReq, opts ...grpc.CallOption) (*SwapResp, error) {
	out := new(SwapResp)
	err := grpc.Invoke(ctx, "/hashresolver.P2P/Swap", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for P2P service

type P2PServer interface {
	// TakeOrder is called to initiate a swap between maker and taker
	// it is a temporary service needed until the integration with XUD
	// intended to be called from CLI to simulate order taking by taker
	TakeOrder(context.Context, *TakeOrderReq) (*TakeOrderResp, error)
	// SuggestDeal is called by the taker to inform the maker that he
	// would like to execute a swap. The maker may reject the request
	// for now, the maker can only accept/reject and can't rediscuss the
	// deal or suggest partial amount. If accepted the maker should respond
	// with a hash that would be used for teh swap.
	SuggestDeal(context.Context, *SuggestDealReq) (*SuggestDealResp, error)
	// Swap initiates the swap. It is called by the taker to confirm that
	// he has the hash and confirm the deal.
	Swap(context.Context, *SwapReq) (*SwapResp, error)
}

func RegisterP2PServer(s *grpc.Server, srv P2PServer) {
	s.RegisterService(&_P2P_serviceDesc, srv)
}

func _P2P_TakeOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TakeOrderReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).TakeOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashresolver.P2P/TakeOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).TakeOrder(ctx, req.(*TakeOrderReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_SuggestDeal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuggestDealReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).SuggestDeal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashresolver.P2P/SuggestDeal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).SuggestDeal(ctx, req.(*SuggestDealReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _P2P_Swap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwapReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(P2PServer).Swap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashresolver.P2P/Swap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(P2PServer).Swap(ctx, req.(*SwapReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _P2P_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashresolver.P2P",
	HandlerType: (*P2PServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TakeOrder",
			Handler:    _P2P_TakeOrder_Handler,
		},
		{
			MethodName: "SuggestDeal",
			Handler:    _P2P_SuggestDeal_Handler,
		},
		{
			MethodName: "Swap",
			Handler:    _P2P_Swap_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "swap_p2p.proto",
}

func init() { proto.RegisterFile("swap_p2p.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 431 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0xc1, 0x8e, 0xd3, 0x30,
	0x10, 0x86, 0xd7, 0x9b, 0xb4, 0xd9, 0xcc, 0x66, 0xcb, 0xca, 0xd2, 0xae, 0xa2, 0xb0, 0x2b, 0x95,
	0x9c, 0x0a, 0x12, 0x39, 0x04, 0x21, 0xce, 0x50, 0x84, 0x40, 0x5a, 0x89, 0x28, 0xcd, 0x3d, 0x72,
	0x89, 0xd5, 0x46, 0xad, 0x1b, 0x63, 0xa7, 0x54, 0x7d, 0x04, 0x1e, 0x84, 0x37, 0xe2, 0xc8, 0xc3,
	0x20, 0x3b, 0x2d, 0x75, 0x28, 0xa4, 0x88, 0x9b, 0x67, 0xfc, 0xfb, 0xf7, 0xcc, 0x97, 0x89, 0x61,
	0x20, 0x37, 0x84, 0xe7, 0x3c, 0xe6, 0x11, 0x17, 0x55, 0x5d, 0x61, 0x4f, 0xc5, 0x82, 0xca, 0x6a,
	0xf9, 0x85, 0x8a, 0xf0, 0x07, 0x02, 0x2f, 0x23, 0x0b, 0xfa, 0x51, 0x14, 0x54, 0xa4, 0xf4, 0x33,
	0xf6, 0xc1, 0xa9, 0xd4, 0xba, 0x2c, 0x7c, 0x34, 0x44, 0x23, 0x37, 0xdd, 0x87, 0xf8, 0x09, 0x78,
	0x35, 0x59, 0x50, 0x91, 0x13, 0x56, 0xad, 0x57, 0xb5, 0x7f, 0x3e, 0x44, 0x23, 0x2b, 0xbd, 0xd4,
	0xb9, 0xd7, 0x3a, 0x85, 0x5f, 0x02, 0x34, 0x92, 0x4f, 0x55, 0xb9, 0xf2, 0xad, 0x21, 0x1a, 0x0d,
	0xe2, 0xdb, 0xc8, 0xbc, 0x30, 0x1a, 0x57, 0xe5, 0x2a, 0xdb, 0x72, 0x9a, 0xba, 0x5a, 0xa9, 0x42,
	0xe5, 0xcc, 0x4c, 0x67, 0xbb, 0x71, 0x66, 0x6d, 0x67, 0x76, 0x70, 0xee, 0x75, 0x3b, 0xb3, 0xbd,
	0x73, 0x18, 0xc1, 0x95, 0xd1, 0x9d, 0xe4, 0xf8, 0x1e, 0x40, 0xe4, 0x5c, 0xd0, 0x92, 0x91, 0x19,
	0xd5, 0x1d, 0x7a, 0xa9, 0x2b, 0x92, 0x5d, 0x22, 0xfc, 0x76, 0x0e, 0x83, 0xc9, 0x7a, 0x36, 0xa3,
	0xb2, 0x7e, 0x4b, 0xc9, 0xb2, 0x1b, 0x48, 0x08, 0x57, 0x4d, 0xb7, 0x05, 0x25, 0xcb, 0xbc, 0x2c,
	0x34, 0x11, 0x77, 0x47, 0x44, 0x1d, 0xff, 0x70, 0x0c, 0xcd, 0x3a, 0x05, 0xcd, 0xfe, 0x5f, 0x68,
	0xbd, 0x53, 0xd0, 0xfa, 0xff, 0x08, 0xed, 0x50, 0x33, 0x5f, 0x4f, 0x17, 0x74, 0xeb, 0x3b, 0x46,
	0x5b, 0x89, 0x4e, 0x85, 0x5f, 0x11, 0x3c, 0x6a, 0x71, 0x92, 0xbc, 0x03, 0xd4, 0x0d, 0xf4, 0x45,
	0x3e, 0x27, 0x72, 0xae, 0x09, 0x79, 0x69, 0x4f, 0xbc, 0x27, 0x72, 0xae, 0xf8, 0xb1, 0x16, 0x3f,
	0xab, 0xb9, 0x88, 0xb5, 0xf9, 0x31, 0xb3, 0x16, 0xdb, 0x90, 0xec, 0x6a, 0x79, 0x0e, 0xce, 0x64,
	0x43, 0xb8, 0xfa, 0x56, 0x47, 0x8e, 0xe8, 0xc8, 0x31, 0x7c, 0x0a, 0x17, 0x8d, 0xfc, 0xe4, 0x34,
	0x3c, 0xbb, 0x83, 0x8b, 0x3d, 0x1f, 0xec, 0x80, 0xf5, 0x26, 0x1b, 0x5f, 0x9f, 0xa9, 0xc5, 0x43,
	0x36, 0xbe, 0x46, 0xf1, 0x77, 0x04, 0x56, 0x12, 0x27, 0xf8, 0x1d, 0xb8, 0xbf, 0x66, 0x0c, 0x07,
	0x6d, 0xbc, 0xe6, 0xaf, 0x15, 0x3c, 0xfe, 0xeb, 0x9e, 0xe4, 0xe1, 0x19, 0x7e, 0x80, 0x4b, 0x03,
	0x29, 0xbe, 0x6b, 0xab, 0xdb, 0x53, 0x19, 0xdc, 0x77, 0xec, 0x6a, 0xb7, 0x57, 0x60, 0xab, 0x36,
	0xf1, 0xcd, 0x6f, 0xc2, 0x86, 0x54, 0x70, 0xfb, 0xa7, 0xb4, 0x3a, 0x38, 0xed, 0xeb, 0x67, 0xe2,
	0xc5, 0xcf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x8b, 0x10, 0x27, 0x91, 0x38, 0x04, 0x00, 0x00,
}
